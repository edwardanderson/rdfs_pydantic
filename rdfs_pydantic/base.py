"""Base class protocols for custom base models in rdfs_pydantic.

This module defines the interface that custom base classes should implement
when passed to create_module() or create_package(). The protocols document
expected attributes that generated classes will use.
"""

from typing import ClassVar, Protocol, runtime_checkable
from pydantic import BaseModel


@runtime_checkable
class RDFSBaseModel(Protocol):
    """Protocol defining the interface for custom base classes.
    
    Custom base classes passed to create_module() or create_package() should
    follow this protocol to ensure proper type checking and functionality.
    
    The protocol defines class variables that generated subclasses will override:
    - _class_iri: The RDF IRI of the class (when emit_iris=True)
    
    Example:
        ```python
        from typing import ClassVar, Any
        from pydantic import BaseModel, model_serializer
        
        class CustomBase(BaseModel):
            '''Custom base that exposes class IRIs in JSON.'''
            
            # Declare that subclasses will have this attribute
            _class_iri: ClassVar[str]
            
            @model_serializer(mode='wrap', when_used='json')
            def serialize_with_type(self, handler) -> Any:
                serialized = handler(self)
                if isinstance(serialized, dict) and hasattr(self.__class__, '_class_iri'):
                    return {'@type': self.__class__._class_iri, **serialized}
                return serialized
        ```
    
    Note:
        The Protocol is marked as runtime_checkable for isinstance() checks,
        but the primary use is for static type checking and documentation.
    """
    
    # ClassVar that subclasses will override with their specific IRI
    _class_iri: ClassVar[str]


class IRIAwareBaseModel(BaseModel):
    """Concrete base class example that's aware of class and property IRIs.
    
    This base class demonstrates the recommended pattern for custom base classes
    that need to access IRI metadata stored by rdfs_pydantic when emit_iris=True.
    
    Subclasses generated by rdfs_pydantic will automatically have:
    - _class_iri: ClassVar[str] containing the RDF class IRI
    - Field json_schema_extra containing '_property_iri' for properties
    
    This base class provides helper methods to access these IRIs programmatically.
    
    Example usage:
        ```python
        from rdflib import Graph
        from rdfs_pydantic import create_module
        from rdfs_pydantic.base import IRIAwareBaseModel
        
        g = Graph()
        g.parse("ontology.ttl")
        
        code = create_module(g, base_cls=IRIAwareBaseModel, emit_iris=True)
        # Generated classes will inherit from IRIAwareBaseModel and can use
        # _get_class_iri() and _get_property_iris()
        ```
    """
    
    # Declare that subclasses will have this ClassVar
    # (subclasses override this with their actual IRI)
    _class_iri: ClassVar[str]
    
    @classmethod
    def _get_class_iri(cls) -> str | None:
        """Get the RDF IRI of this class.
        
        Returns:
            The class IRI string if defined, None otherwise.
        """
        return getattr(cls, '_class_iri', None)
    
    @classmethod
    def _get_property_iris(cls) -> dict[str, str]:
        """Get a mapping of property names to their RDF IRIs.
        
        Returns:
            Dictionary mapping field names to their RDF property IRIs.
            Only includes properties that have IRI metadata.
        """
        iris = {}
        for field_name, field_info in cls.model_fields.items():
            extra = field_info.json_schema_extra
            # json_schema_extra can be a dict or a callable
            if isinstance(extra, dict) and '_property_iri' in extra:
                iris[field_name] = extra['_property_iri']
        return iris
